spring.profiles.active=postgres

# Server Configuration - Allow connections from other devices
server.address=0.0.0.0
server.port=${PORT:8080}
server.servlet.context-path=/myapp

# Allow bean definition overriding
spring.main.allow-bean-definition-overriding=true

# Application Base URL Configuration
# Change this URL when deploying to different environments
app.base-url=http://202.65.155.125:8080/myapp
app.frontend-url=http://localhost:4200

# Google OAuth2 Configuration
google.oauth2.client-id=333815600502-fcfheqik99ceft5sq5nk4f8ae5aialec.apps.googleusercontent.com

# Google Custom Search API Configuration
google.customsearch.api-key=${GOOGLE_API_KEY:YOUR_GOOGLE_API_KEY}
google.customsearch.cx=${GOOGLE_CSE_ID:YOUR_GOOGLE_CSE_ID}

# HTTP Client Timeouts - Extended for debugging
http.client.timeout.connect=30000
http.client.timeout.read=300000

# Swagger/OpenAPI Configuration
springdoc.api-docs.path=/v3/api-docs
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.swagger-ui.operationsSorter=method
springdoc.swagger-ui.tagsSorter=alpha
springdoc.swagger-ui.tryItOutEnabled=true
springdoc.swagger-ui.filter=true
springdoc.swagger-ui.disable-swagger-default-url=true
springdoc.swagger-ui.display-request-duration=true
springdoc.swagger-ui.doc-expansion=none
springdoc.swagger-ui.configUrl=/myapp/v3/api-docs/swagger-config
springdoc.swagger-ui.urls[0].url=/myapp/v3/api-docs
springdoc.swagger-ui.urls[0].name=JWT Authenticator API
springdoc.paths-to-match=/auth/**, /api/**, /test/**, /actuator/**

# Brand ID Configuration
brand.id.prefix=MRTFY
brand.id.number.padding=6

# User ID Configuration
user.id.prefix=DOMBR
user.id.number.padding=6

# Forward API settings
app.forward.timeout-seconds=300
app.forward.cache-ttl-seconds=3600
app.forward.rate-limit.requests-per-minute=100

# JWT settings - Use environment variables for production
jwt.secret=${JWT_SECRET:mySecretKeyThatIsAtLeast256BitsLongForJwtTokenGeneration12345}
jwt.issuer=${JWT_ISSUER:mrtfy-example}
jwt.expiry-seconds=${JWT_EXPIRY_SECONDS:86400}

# Brand Extraction Configuration
app.brand-extraction.enabled=true

# File Storage Configuration
# Choose one: local, http, sftp, s3, gcs
app.file-storage.type=sftp
app.file-storage.local.base-path=D:/Brand_Assets
app.file-storage.server.base-url=http://202.65.155.125:8080/images/Brand_Assets

# User Profile Image Storage Configuration (uses same storage type as brands)
# Profile images will be stored under users/{userId}/profile/ structure

# HTTP Upload Configuration
app.file-storage.remote.upload-url=http://202.65.155.125:8080/images/upload
app.file-storage.remote.auth-token=
app.file-storage.remote.timeout-seconds=30

# SFTP Configuration - Use environment variables for credentials
app.file-storage.remote.host=${SFTP_HOST:202.65.155.125}
app.file-storage.remote.port=${SFTP_PORT:22}
app.file-storage.remote.username=${SFTP_USERNAME:ubuntu}
app.file-storage.remote.password=${SFTP_PASSWORD:sAFtR6r06nmH}
app.file-storage.remote.base-path=${SFTP_BASE_PATH:/home/ubuntu/images/Brand_Assets}
app.file-storage.remote.pool.min-size=2
app.file-storage.remote.pool.max-size=5

# Download Configuration
app.file-storage.download.timeout-seconds=30
app.file-storage.download.max-file-size=10485760
app.file-storage.download.max-attempts=3

# Async Processing Configuration - Balanced with HikariCP pool (54 max connections)
spring.task.execution.pool.core-size=12
spring.task.execution.pool.max-size=30
spring.task.execution.pool.queue-capacity=500
spring.task.execution.thread-name-prefix=async-
spring.task.execution.pool.keep-alive=120s
spring.task.execution.pool.allow-core-thread-timeout=true

# FreeMarker Configuration
spring.freemarker.template-loader-path=classpath:/static/templates/
spring.freemarker.suffix=.ftl
spring.freemarker.cache=false
spring.freemarker.charset=UTF-8
spring.freemarker.check-template-location=true
spring.freemarker.content-type=text/html

# Email Configuration
spring.mail.host=${MAIL_HOST:smtp.gmail.com}
spring.mail.port=${MAIL_PORT:587}
spring.mail.username=${MAIL_USERNAME:tyedukondalu@stratapps.com}
spring.mail.password=${MAIL_PASSWORD:whesvjdtjmyhgwwt}
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true

# API Key Analytics Configuration
app.analytics.request-logging.enabled=true
app.analytics.async-logging=true

# Security Configuration (IP/Domain validation - disabled by default for testing)
app.security.ip-validation.enabled=false
app.security.domain-validation.enabled=false

# Dashboard Scheduler Configuration - DISABLED (not needed - dashboard queries DB directly)
dashboard.scheduler.enabled=false
# dashboard.scheduler.fixed-rate=7200000
# ✅ DISABLED: Dashboard scheduler removed - dashboard queries real-time data from DB
# 7200000 = 2 hours (in milliseconds)
# 3600000 = 1 hour (in milliseconds)
# 1800000 = 30 minutes
# 900000 = 15 minutes
# 600000 = 10 minutes
# 300000 = 5 minutes


# Logging Configuration for debugging
logging.level.com.example.jwtauthenticator.service.ApiKeyRequestLogService=INFO
logging.level.org.springframework.security=DEBUG
# logging.level.com.example.jwtauthenticator.service.DashboardSchedulerService=INFO  # DISABLED - scheduler removed
logging.level.com.example.jwtauthenticator.service.UserDashboardService=DEBUG
logging.level.com.example.jwtauthenticator.repository.ApiKeyRequestLogRepository=DEBUG

# Console logging pattern to see timestamps and thread info
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n

# Optional: Log to file as well
# logging.file.name=logs/application.log
# logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n

# Connection Pool Monitoring
logging.level.com.zaxxer.hikari.HikariConfig=INFO
logging.level.com.zaxxer.hikari=INFO

# Database Connection Health Check
management.endpoint.health.show-details=always
management.endpoints.web.exposure.include=health,info,metrics,hikaricp


# ✅ DEBUGGING: Additional debugging configurations
app.debug.mode=false
app.debug.skip-heavy-validations=false
app.debug.extended-timeouts=true

# ====================================================================
# MONTHLY QUOTA RESET CONFIGURATION
# ====================================================================

# Enable/disable monthly quota reset scheduler
app.quota.reset.enabled=true

# Cron expression for monthly reset - runs at 00:01 UTC on 1st of every month
# Format: "second minute hour day-of-month month day-of-week"
# Default: "0 1 0 1 * ?" = 1 minute past midnight on the 1st of every month
app.quota.reset.cron=0 1 0 1 * ?

# Processing configuration
app.quota.reset.batch-size=100
app.quota.reset.transaction-timeout=300

# Logging configuration for quota reset
logging.level.com.example.jwtauthenticator.scheduler.MonthlyQuotaResetScheduler=INFO

# ====================================================================
# RIVO9 COMPANY CONFIGURATION
# ====================================================================

# Company Information
app.company.name=RIVO9
app.company.support-email=support@rivo9.com
app.company.website=https://rivo9.com
app.company.admin-emails=admin@rivo9.com,tech@rivo9.com

# Email Notification Configuration
app.notifications.quota-reset.enabled=true
app.notifications.quota-reset.send-user-emails=true
app.notifications.quota-reset.send-admin-emails=true
app.notifications.quota-reset.rate-limit-ms=100

# Audit Configuration
app.audit.quota-reset.enabled=true
app.audit.quota-reset.cleanup-days=365

# ====================================================================
# RIVOFETCH CONFIGURATION (SIMPLIFIED)
# ====================================================================

# RivoFetch uses Spring's default @Async executor for simplicity
# No custom thread pool configuration needed - Spring Boot handles it intelligently

# RivoFetch Logging Configuration
app.rivofetch.logging.enabled=true
app.rivofetch.logging.async=true

# RivoFetch Performance Monitoring (optional)
app.rivofetch.monitoring.enabled=true
app.rivofetch.monitoring.slow-request-threshold-ms=5000

# ====================================================================
# CONNECTION POOL MONITORING & OPTIMIZATION
# ====================================================================

# Connection Pool Health Monitoring - Optimized for PostgreSQL max_connections=90
app.monitoring.connection-pool.enabled=true
app.monitoring.connection-pool.check-interval-seconds=30
# Pool uses max 54/90 connections (~60%), warnings at 75% pool usage (40 connections)
app.monitoring.connection-pool.warning-threshold=75  
app.monitoring.connection-pool.critical-threshold=85
app.monitoring.connection-pool.alert-enabled=true

# Thread Pool Monitoring
app.monitoring.thread-pool.enabled=true
app.monitoring.thread-pool.check-interval-seconds=60
app.monitoring.thread-pool.queue-warning-threshold=80
app.monitoring.thread-pool.active-thread-warning-threshold=90

